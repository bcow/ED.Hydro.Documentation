---
title: "06-Taxonomy"
output:
  html_document: default
  html_notebook: default
---

# Taxonomic Name Resolution when Importing Data in to BETY

## Name Resolution {}

When users have plant trait data that they want to enter in to the database, the data needs to attributed to a specific species database entry. When the user has no other information (such as ID codes such as the USDA and FIA codes) the only way to match the species in the data with species entry in the database is through matching of scientific names.

But it may be the case that the accepted scientific name has changed since the data was collected (and/or published), or that the data itself contains errors (typos or otherwise) such that the names in the data are not matching with anything that has already been entered in to BETY. It is also the case that BETY does not have a complete record. 

At this point we need to employ additional tools to help us in resolving taxonomic names. 
Already in the PEcAn code there exists 

-  [`match_species_id`](https://github.com/PecanProject/pecan/blob/develop/modules/data.land/R/match_species_id.R): But this cannot account for fuzzy matching of names (ie spelling errors) and synonyms. 
-  [`94.match.species`](https://github.com/PecanProject/pecan/blob/297087787cfec6129428e1e334297ed2b6030a06/base/db/inst/import-try/94.match.species.R): This code is specific to importing data from thr TRY database and experiments with some partial matching through grep statements, but again does not account for synonyms.

Outside of PEcAn, there is the [Taxonomic Name Resolution Service](http://tnrs.iplantcollaborative.org/TNRSapp.html)

Additionally, there is an R package [taxize](https://ropensci.github.io/taxize-book/) which, among other things, provides an R interface between TNRS and R. 

I recommend checking out their [vignettes](https://cran.r-project.org/web/packages/taxize/vignettes/) - you can also just access them on their [github](https://github.com/ropensci/taxize).

## Building a Tropical PFT {}

the goal of all of this is not only to import trait data, but to build a PFT that I can used to do runs in the tropics. __(How general should this PFT be? That's a good question!)__

Right now I'm using a clone of the tropical PFT that was made to be used with FATES. Thus it contains all the imported BETY entries from the ForestGEO Neotropical tree database (http://ctfs.si.edu/webatlas/neotropicaltree/) and more. There are currently 22286 species linked to the PFT, 20811 of which are the ForestGEO entries. 

If I'm importing data with species that are not in the existing PFT, I need to decide if they should be added. And I suppose I should also make sure there aren't any species in the PFT that shouldn't be there. This is something that I have no expertise in so I would like advice. 

```{r, include=FALSE, message=FALSE}
suppressPackageStartupMessages(library(ED.Hydro.Helpers))
suppressPackageStartupMessages(library(kableExtra))
bety <- betyConnect("/fs/data3/ecowdery/pecan/web/config.php")
```


```{r}

pftid <- 1000000131
PFT_species <- tbl(bety, "pfts") %>% dplyr::rename(pft_id = id) %>% filter(pft_id == pftid) %>%
  inner_join(., tbl(bety, "pfts_species"), by = "pft_id") %>%
  inner_join(., tbl(bety, "species") %>% dplyr::rename(specie_id = id), by = "specie_id") %>%
  dplyr::select(one_of("pft_id", "name", "specie_id", "genus", "species", "scientificname", "notes")) %>%
  collect()

# Check that all the ForestGEO species are in the PFT (they are)
nForestGEO <- tbl(bety, "species") %>% filter(str_detect(notes, "ForestGEO")) %>% collect() %>% nrow()
PFT_species %>% filter(str_detect(PFT_species$notes, "ForestGEO")) %>% nrow() == nForestGEO

PFT_species$notes <- NULL

```

## The point of all this

I'm running four tests:

I'll refer to the species name in the data set as "submitted name" 
and the name returned throught the TNRS 
(that is specifically classified as an accepted name) as "accepted name."

1) Does the submitted name have an exact match in the database (ie return a species entry id)? If yes, `submit_bety = TRUE`.
2) If `submit_bety = TRUE`, is the resulting species id in the PFT? If yes, `submit_PFT = TRUE`

Then feed the submitted name through the TNRS and (hopefully) recieve an accepted name:

3) Does the accepted name have an exact match in the database (ie return a species entry id)? If yes, `accept_bety = TRUE`.
4) If `accept_bety = TRUE`, is the resulting species id in the PFT? If yes, `accept_PFT = TRUE`

From this we can come up with the following cases:

```{r, eval = FALSE}


```

For a list of 131 species from trait data that needs to be imported in to BETY (from various sources), I determined the case for each species in a separate script. The result of this analysis are in the file `/fs/data3/ecowdery/ED.Hydro/parameters/constraint_calculations/constraint_data/species_out.csv`.

```{r}
species_out = read.csv(file = "/fs/data3/ecowdery/ED.Hydro/parameters/constraint_calculations/constraint_data/species_out.csv",
                       stringsAsFactors = FALSE)

# Special case for which the TNRS did not work, I'll get to this later
species_special <- species_out %>% filter(is.na(accept_name) | accept_name == "" | accept_name == " ")

# Entries for which the TNRS did work
species_case <- species_out %>% filter(!is.na(accept_name))
# dim(species_case)

# Here I color the entries by "score" which is just how "close" the match is
# So the score would go down for a spelling error for example
ggplot(data = species_case) + 
  geom_bar(aes(x = as.factor(case), fill = as.factor(score)))

```

Luckily, case 6, the once in which the submitted name and accepted name agree and are in BETY and in the tropical PFT is the predominant case. However, there are a lot of other cases that need sorting through. This is where I need help. 


## Cases {}

### Neither in bety {}

#### Case 1 {}

`case01 <- !submit_bety & !accept_bety`

__My opinion:__ 
- Add the accepted name to the databse and to the PFT.
- Enter the 

```{r, echo = FALSE}
library(kableExtra)
c1 <- species_case %>% filter(case == 1)
kable(c1) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

# Check if any the submitted name and accepted names are different 
UGH <- apply(c1, 1, function(x) toupper(x[3]) != toupper(x[6])) %>% which()

c1[19,"accept_name"] == ""

c1[UGH,]

```


### Submit not in bety, accept in bety {}

#### Case 2 {}

`case02 <- !submit_bety & accept_bety & accept_PFT`

```{r, echo = FALSE}
library(kableExtra)
kable(species_case %>% filter(case == 2)) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

#### Case 3 {}

`case03 <- !submit_bety & accept_bety & !accept_PFT`

```{r, echo = FALSE}
library(kableExtra)
kable(species_case %>% filter(case == 3)) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

### Submit in bety, accept not in bety {}

#### Case 4 {}

`case04 <- submit_bety & submit_PFT & !accept_bety`

```{r, echo = FALSE}
library(kableExtra)
kable(species_case %>% filter(case == 4)) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

#### Case 5  {}

`case05 <- submit_bety & !submit_PFT & !accept_bety`

```{r, echo = FALSE}
library(kableExtra)
kable(species_case %>% filter(case == 5)) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

### Both in bety and they equal each other {}

#### case06 <- submit_bety & accept_bety & submit_accept & accept_PFT {}



#### case07 <- submit_bety & accept_bety & submit_accept & !accept_PFT {}

### Both in BETY and they don't equal one another {}

#### case08 <- submit_bety & accept_bety & !submit_accept & submit_PFT & accept_PFT {}

#### case09 <- submit_bety & accept_bety & !submit_accept & submit_PFT & !accept_PFT {}

#### case10 <- submit_bety & accept_bety & !submit_accept & !submit_PFT & accept_PFT {}

#### case11 <- submit_bety & accept_bety & !submit_accept & !submit_PFT & !accept_PFT {}
